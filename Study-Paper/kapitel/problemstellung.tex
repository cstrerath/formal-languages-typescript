% !TEX root = ../master.tex

\section{Problemstellung, Ziel und Vorgehensweise der Arbeit}
\label{sec:problemstellung}

\subsection{Problemstellung}
In der Lehrveranstaltung \emph{Formale Sprachen} an der Dualen Hochschule Baden-Württemberg werden zentrale Inhalte durch ausführbare Programme in Python vermittelt. Die Beispiele behandeln unter anderem Tokenisierung (Scanner), Syntaxanalyse (Parsing), den Umgang mit Konflikten in Grammatiken sowie die Konstruktion und Weiterverarbeitung abstrakter Syntaxbäume (AST). Damit bewegen sich die Programme in einem typischen \emph{compiler-nahen} Kontext, in dem strukturierte Datenmodelle und klar definierte Verarbeitungsphasen eine zentrale Rolle spielen.

Python ist jedoch eine \emph{dynamisch typisierte} Sprache. Typinformationen werden erst zur Laufzeit überprüft und können sich während der Programmausführung verändern. Fehler wie inkonsistente AST-Strukturen, falsche Operanden-Typen oder fehlerhafte Umgebungsabbildungen werden daher häufig erst dann sichtbar, wenn ein konkreter Ausführungspfad die betreffende Stelle erreicht. Insbesondere in mehrstufigen Verarbeitungsketten
\[
\text{Scanner} \rightarrow \text{Parser} \rightarrow \text{AST-Transformation} \rightarrow \text{Semantik}
\]
erschwert dies die Lokalisierung von Fehlerursachen erheblich.

Zur Verbesserung der Typdisziplin wird im Rahmen der Lehrveranstaltung \texttt{mypy} eingesetzt. Dabei handelt es sich um einen statischen Typchecker für Python, der auf Grundlage von Typannotationen eine Überprüfung der Typkonsistenz bereits vor der Programmausführung ermöglicht. Fehlerklassen wie inkonsistente Rückgabetypen oder fehlerhafte Verwendungen parametrischer Datentypen (z.\,B.\ \texttt{Set[str]} oder \texttt{Dict[str, Set[str]]}) können so frühzeitig erkannt werden. Python nähert sich dadurch partiell einer statisch typisierten Disziplin an, ohne jedoch seine dynamische Semantik grundsätzlich zu verändern.

Die Typprüfung bleibt optional und erzwingt keine vollständige strukturelle Absicherung der verwendeten Datenmodelle. Gerade im Kontext formaler Sprachen arbeiten die Programme mit stark verschachtelten und semantisch sensiblen Strukturen. Diese müssen wohldefinierte Invarianten erfüllen, etwa: Ein binärer Ausdruck besitzt genau zwei Operanden; Tokens gehören exakt zu einer definierten Kategorie; Umgebungen ordnen Bezeichner eindeutig Werte zu. In einer dynamisch typisierten Sprache werden solche Strukturbedingungen typischerweise durch Laufzeitprüfungen, Konventionen oder Tests abgesichert, nicht jedoch durch das Typsystem selbst.

Ein weiterer praktisch relevanter Aspekt ergibt sich bei der Modellierung \emph{mathematischer Objekte} wie Mengen, Relationen oder Zustandsmengen von Automaten. In den Programmen des Vorlesungsskripts wird beispielsweise \texttt{frozenset} in Kombination mit PLY eingesetzt, um Mengen unveränderbar zu machen und sie dadurch zuverlässig als Elemente anderer Mengen oder als Schlüssel in Dictionaries verwenden zu können \autocite{stroetmann_formal_languages_repo}. Die Notwendigkeit solcher Konstruktionen verdeutlicht, dass zentrale semantische Eigenschaften, hier die Unveränderlichkeit von Mengen, nicht auf Sprachebene garantiert, sondern explizit programmiert werden müssen.

Aus der vorangegangenen Analyse lassen sich folgende strukturelle Problemfelder identifizieren:

\begin{enumerate}
    \item \textbf{Fehlende verpflichtende statische Typprüfung.}  
    Die Typüberprüfung durch \texttt{mypy} ist optional und nicht integraler Bestandteil der Sprache. Programme bleiben auch ohne Typannotationen lauffähig, wodurch Typfehler weiterhin erst zur Laufzeit auftreten können.

    \item \textbf{Unzureichende formale Absicherung struktureller Invarianten.}  
    Zentrale Datenstrukturen wie Syntaxbäume oder Zustandsmengen müssen bestimmte Eigenschaften erfüllen (z.\,B.\ Anzahl von Operanden, eindeutige Zuordnung von Symbolen). Diese Strukturbedingungen werden jedoch nicht durch das Typsystem garantiert, sondern lediglich durch Konventionen oder Laufzeitprüfungen abgesichert.

    \item \textbf{Erschwerte Modellierung mathematischer Strukturen.}  
    Mathematische Objekte wie Mengen oder Relationen müssen explizit so implementiert werden, dass ihre semantischen Eigenschaften (z.\,B.\ Unveränderlichkeit) erhalten bleiben. Die Verwendung von \texttt{frozenset} ist hierfür ein Beispiel. Solche Eigenschaften werden nicht automatisch durch das Sprachdesign erzwungen.

    \item \textbf{Veränderbarkeit von Daten als Standardverhalten.}  
    Viele Datenstrukturen in Python sind standardmäßig veränderbar. Dadurch können Objekte unbeabsichtigt modifiziert werden, was insbesondere bei verschachtelten oder gemeinsam genutzten Datenstrukturen zu schwer nachvollziehbaren Fehlern führen kann.

    \item \textbf{Fehlende sprachliche Unterstützung für klar strukturierte Datentypen.}  
    Für die Modellierung unterschiedlich geformter AST-Knoten oder Zustände existieren keine strikt getrennten Datentypen mit automatischer Vollständigkeitsprüfung. Fehlerhafte oder unvollständige Fallunterscheidungen werden daher häufig nicht bereits beim Übersetzen des Programms erkannt.
\end{enumerate}

\subsection{Zielsetzung}
Aus den identifizierten Problemfeldern ergibt sich die zentrale Fragestellung dieser Arbeit: 
Inwieweit kann eine systematische Übersetzung der Python-Programme in die statisch typisierte Sprache TypeScript die strukturellen und typbezogenen Schwächen der bestehenden Implementierungen reduzieren?

Ziel der Arbeit ist es, die im Vorlesungsskript verwendeten Python-Programme formal zu analysieren und in TypeScript zu übertragen. Dabei soll untersucht werden,

\begin{itemize}
    \item in welchem Maße sich strukturelle Invarianten durch das Typsystem explizit modellieren lassen,
    \item ob mathematische Objekte wie Mengen und Zustandsmengen präziser typisiert werden können,
    \item und welche Unterschiede sich hinsichtlich Fehlererkennung, Wartbarkeit und Modellklarheit ergeben.
\end{itemize}

Die Arbeit verfolgt dabei keinen rein technischen Portierungsansatz, sondern eine formale Gegenüberstellung beider Typdisziplinen im Kontext compiler-naher Strukturen.
