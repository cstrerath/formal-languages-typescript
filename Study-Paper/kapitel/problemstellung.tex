% !TEX root = ../master.tex

\section{Problemstellung, Ziel und Vorgehensweise der Arbeit}
\label{sec:problemstellung}

In der Lehrveranstaltung \emph{Formale Sprachen} liegen zentrale Inhalte und Übungsbeispiele in Form ausführbarer Python-Programme vor, die Konzepte wie Tokenisierung, Syntaxanalyse (Parsing), Konfliktbehandlung in Grammatiken sowie die Ableitung und Verarbeitung abstrakter Syntaxbäume (AST) praktisch demonstrieren. Ziel dieser Studienarbeit ist es, diese Vorlesungsunterlagen systematisch nach TypeScript zu übertragen und dabei die fachlichen Inhalte unverändert zu erhalten, jedoch die Implementierung an die Eigenschaften einer statisch typisierten Sprache anzupassen.

\medskip

Python ist \emph{dynamisch typisiert}: Typinformationen werden zur Laufzeit bestimmt und können sich während der Programmausführung ändern. Dadurch werden zahlreiche Fehler (z.\,B.\ falsche Datentypen in Ausdrücken, inkonsistente AST-Knoten oder fehlerhafte Umgebungsabbildungen) typischerweise erst beim Ausführen relevanter Codepfade sichtbar. Für Lehrbeispiele aus dem Bereich formaler Sprachen ist dies problematisch, da viele Fehler erst in späteren Phasen der Verarbeitungskette (Scanner $\rightarrow$ Parser $\rightarrow$ AST-Transformation $\rightarrow$ Semantik) auftreten und dann schwerer zu lokalisieren sind. TypeScript hingegen ergänzt JavaScript um ein statisches Typsystem, das Konsistenzprüfungen bereits zur Übersetzungszeit ermöglicht und damit Fehler früher erkennbar macht. 

\medskip

Diese frühe Fehlererkennung ist insbesondere bei den von uns portierten \emph{compiler-nahen} Datenstrukturen wichtig: In den Notebooks werden Tokens, Parse-Bäume und AST-Knoten verarbeitet, die stark verschachtelt sind und klare Strukturinvarianten besitzen. Konkret modellieren wir beispielsweise den AST nicht als untypisierte Dictionaries, sondern als rekursiven Union-Typ
\mintinline{typescript}{export type AST = NumNode | VarNode | ... | BinaryExpr | ...;}
und erzwingen die Form einzelner Knoten über typsichere Tupel-Layouts, etwa
\mintinline{typescript}{class BinaryExpr extends ASTNode<Tuple<[AST, string, AST]>>}
wodurch ein Binäroperator \emph{zwingend} genau zwei Operanden (links/rechts) besitzt und in dieser Form konsistent verwendet wird. Ebenso wird die Ausführungsumgebung explizit als
\mintinline{typescript}{type Environment = Map<string, number>}
repräsentiert, sodass Variablennamen stets wohldefinierten (numerischen) Werten zugeordnet sind. In dynamisch typisiertem Python müssten solche Eigenschaften überwiegend über Laufzeitprüfungen, Konventionen oder Tests abgesichert werden; mit TypeScript werden viele dieser Fehlerklassen bereits beim Übersetzen erkannt, weil bestimmte fehlerhafte Zustände gar nicht erst typisierbar (und damit nicht repräsentierbar) sind. \autocite[S.~3]{pierce2002tapl}%
Zudem passt dieses Vorgehen zur klassischen Compiler-Pipeline, in der aus einem Tokenstrom strukturierte Baumrepräsentationen (Syntaxbäume/ASTs) aufgebaut und anschließend weiterverarbeitet werden. \autocite[S.~5, S.~8]{aho2006compilers}
