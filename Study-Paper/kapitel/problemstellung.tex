% !TEX root = ../master.tex

\section{Problemstellung, Ziel und Vorgehensweise der Arbeit}
\label{sec:problemstellung}

\subsection{Problemstellung}
In der Lehrveranstaltung \emph{Formale Sprachen} an der Dualen Hochschule Baden-Württemberg werden zentrale Inhalte und Übungsaufgaben durch ausführbare Programme in Python vermittelt. Die Beispiele illustrieren u.\,a.\ Tokenisierung (Scanner), Syntaxanalyse (Parsing), 
den Umgang mit Konflikten in Grammatiken sowie die Konstruktion und Weiterverarbeitung abstrakter Syntaxbäume (AST). Dabei ist Python \emph{dynamisch typisiert}, d.\,h.\ die Typinformationen werden erst zur Laufzeit festgelegt und können sich während der Ausführung ändern. Dies hat zur Folge, dass viele Fehler (wie z.\,B.\ falsche Operanden-Typen, inkonsistente AST-Knoten oder fehlerhafte Umgebungsabbildungen) häufig erst dann sichtbar werden, wenn ein konkreter Ausführungspfad diese Stelle erreicht.

\medskip

Für Lehrbeispiele aus dem Bereich formaler Sprachen ist dies besonders nachteilig, weil die Fehler oft erst in späteren Phasen der Verarbeitungskette \\(Scanner $\rightarrow$ Parser $\rightarrow$ AST-Transformation $\rightarrow$ Semantik) auftreten und somit schwieriger zu lokalisieren sind. In \emph{compiler-nahen} Strukturen sind die Daten zudem stark verschachtelt und müssen klare Invarianten erfüllen (z.\,B.\ hat ein binärer Ausdruck genau zwei Operanden; Tokens besitzen wohldefinierte Formen; Umgebungen ordnen Namen konsistent Werte zu). In dynamisch typisiertem Code werden solche Invarianten typischerweise über Laufzeitprüfungen, Konventionen oder Tests abgesichert.

Im Vorlesungsskript ergeben sich weitere praktisch relevante Nachteile von Python. Insbesondere in dem Fall wo \emph{mathematische Objekte} (Mengen, Relationen, Zustandsmengen von Automaten) in Programmstrukturen abgebildet werden sollen. In den ausführbare Programmen wird beispielsweise \texttt{frozenset} mit Ply eingesetzt, um Mengen \emph{unveränderbar} zu machen und sie dadurch zuverlässig als Elemente anderer Mengen bzw.\ als Schlüssel in Dictionaries verwenden zu können. \autocite{stroetmann_formal_languages_repo}
Daraus lassen sich mehrere konkrete Problemfelder ableiten:

\begin{itemize}
  \item \textbf{Immutabilität muss erzwungen werden:}
  In Python sind \texttt{set}s veränderbar. Wird eine Menge nachträglich mutiert, können sich Invarianten unbemerkt ändern (z.\,B.\ Zustandsmengen, berechnete Abschlussmengen, First/Follow-Mengen). Um diesen Fehlerklassen vorzubeugen, muss im Skript explizit auf \texttt{frozenset} ausgewichen werden. \autocite{stroetmann_formal_languages_repo}

  \item \textbf{Fehlende Hashbarkeit veränderbarer Mengen:}
  Da \texttt{set} nicht hashbar ist, kann es nicht als Element einer Menge und nicht als Dictionary-Key auftreten. Für typische Konstruktionen in der formalen Sprachenwelt (z.\,B.\ Zustandsmengen als DFA-Zustände bei der Potenzmengenkonstruktion) ist das aber zentral. Der Umweg über \texttt{frozenset} und \texttt{Tupel} ist funktional, macht die Modelle jedoch indirekter und erfordert zusätzliche Konvertierungen. \autocite{stroetmann_formal_languages_repo}

  \item \textbf{Mehr Konvertierungen und Kopier-Overhead:}
  Wenn zwischen \texttt{set} (für Aufbau/Operationen wie Vereinigung) und \texttt{frozenset} (für stabile Repräsentation) gewechselt werden muss, entstehen zusätzliche Konstruktionen und Speicherallokationen, die den Code aufblähen und die Ausführung in iterativen Algorithmen (z.\,B.\ Fixpunktberechnungen) messbar belasten können. \autocite{stroetmann_formal_languages_repo}

  \item \textbf{Implizite Strukturverträge statt Typsignaturen:}
  Ob ein Objekt in einem bestimmten Kontext \texttt{set} oder \texttt{frozenset} sein muss, bleibt in Python oft eine \glqq stillschweigende\grqq{} Konvention, die erst bei einem Laufzeitfehler auffällt (z.\,B.\ \texttt{TypeError: unhashable type: 'set'}). In einer statisch typisierten Implementierung kann diese Unterscheidung als Typ modelliert und damit früh geprüft werden. \autocite[S.~3]{pierce2002tapl}

  \item \textbf{Schwierigeres Refactoring bei wachsenden Notebooks:}
  Sobald sich die verwendeten Mengen-/Relationstypen in mehreren Kapiteln wiederholen, führt jede Änderung (z.\,B.\ Wechsel von \texttt{set} zu \texttt{frozenset} an Schnittstellen) leicht zu inkonsistenten Stellen, weil Python solche Brüche nicht \emph{kompilierzeitlich} meldet. Das erschwert die Weiterentwicklung einer kapitelübergreifenden Codebasis.
\end{itemize}

\subsection{Zielsetzung}
